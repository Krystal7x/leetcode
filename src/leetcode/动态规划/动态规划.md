动态规划问题的一般形式就是求最值。比如说让你求最长递增子序列呀，最小编辑距离呀等等。
动态规划问题一定会具备「最优子结构」，通过子问题的最值得到原问题的最值。
在递增的过程中，我们需要得出状态转移函数，它表示，在过程中，问题的状态是如何转变的，一般状态有几种，就需要几维dp数组记录



for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 择优(选择1，选择2...)

经典题目
1、最长递增子序列
L647 最长且连续的的递增序列(子串)长度
L300 最长可不连续的递增序列(子序列)长度


2、最长公共子序列
前文「最长公共子序列」说过，解决两个字符串的动态规划问题，一般都是用两个指针 i,j 分别指向两个字符串的最后，然后一步步往前走，缩小问题的规模。
L72 编辑距离  可以从递归看到动态规划


3、背包问题
0-1背包(每个物品一次)  装入背包的价值最大
子集背包(每个物品一次)  可装载重量为sum/2的背包和N个物品，每个物品的重量为nums[i]，是否存在一种装法，能够恰好将背包装满（L416）
完全背包(每个物品无数次)  每个物品的数量无限。请问有多少种方法，能够把背包恰好装满（0811 L518  零钱兑换）

4、高楼扔鸡蛋
L887  难啊，考虑具体细节有点难，但可以直接根据状态列出 for循环 和 状态转移算子  在列出base case 就好了
5、戳气球
L312 也难啊



