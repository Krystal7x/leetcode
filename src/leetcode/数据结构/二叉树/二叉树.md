#队列遍历
void traverse(ListNode head) {
    // 递归访问 head.val
    traverse(head.next)
}
#二叉树遍历
void traverse(TreeNode root) {
    traverse(root.left)
    traverse(root.right)
}
#N叉树遍历
void traverse(TreeNode root) {
    for (TreeNode child : root.children)
        traverse(child);
}


##几乎所有二叉树的题目都是一套这个框架就出来了。
#二叉树算法的设计的总路线：写二叉树的算法题，都是基于递归框架的，我们先要搞清楚root节点它自己要做什么，然后根据题目要求选择使用前序，中序，后续的递归框架。

void traverse(TreeNode root) {
    // 前序遍历
    traverse(root.left)
    // 中序遍历
    traverse(root.right)
    // 后序遍历
}
#####################################################################

刷算法题建议从「树」分类开始刷，结合框架思维，
把这几十道题刷完，对于树结构的理解应该就到位了。
这时候去看回溯、动规、分治等算法专题，对思路的理解可能会更加深刻一些。

#####################################################################
#搜索二叉树（中序） BST  
L95*  输出存在几种二叉树，动态规划
L96*  和上面一样，输出存在几种二叉树，动态规划  dp[i] = dp[j - 1] * dp[i - j] + dp[i]

L98*  判断其是否是一个有效的二叉搜索树  中序遍历一下
L100  两棵树是否相同  先序遍历

L450  删出一个节点 ，移动到右边最左的节点，再删
L700  查找一个节点
L701  增加一个节点


#完全二叉树 
L222 递归求 完全二叉树 节点数



###遍历最重要(DFS + BFS) 
L94***（前中后）, 
L102  树的层次遍历   L107
L103  之字输出二叉树  两个栈
L114*  树展开为一个单链表
0409*  所有可能生成二叉树的数组  队列记录所有候选集,有点回溯的意思 

#重组二叉树（递归） 
L95* 
L105*  前序与中序遍历序列构造二叉树
L108   升序数，转换为平衡二叉搜索树AVL