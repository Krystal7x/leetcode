package leetcode.数组;

/**
 * 描述:
 * 978. 最长湍流子数组
 * 当 A 的子数组 A[i], A[i+1], ..., A[j] 满足下列条件时，我们称其为湍流子数组：
 * <p>
 * 若 i <= k < j，当 k 为奇数时， A[k] > A[k+1]，且当 k 为偶数时，A[k] < A[k+1]；
 * 或 若 i <= k < j，当 k 为偶数时，A[k] > A[k+1] ，且当 k 为奇数时， A[k] < A[k+1]。
 * 也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。
 * <p>
 * 返回 A 的最大湍流子数组的长度。
 * <p>
 * <p>
 * <p>
 * 示例 1：
 * 输入：[9,4,2,10,7,8,8,1,9]
 * 输出：5
 * 解释：(A[1] > A[2] < A[3] > A[4] < A[5])
 * <p>
 * 示例 2：
 * 输入：[4,8,12,16]
 * 输出：2
 * <p>
 * <p>
 * 示例 3：
 * 输入：[100]
 * 输出：1
 * <p>
 * <p>
 * 提示：
 * <p>
 * 1 <= A.length <= 40000
 * 0 <= A[i] <= 10^9
 *
 * @author luokui
 * @create 2020-05-20 12:10
 */
public class L978_Solution {
    /**
     *
     我们要找的就是这种上升和下降交替的波形子数组，也也是题目叫“湍流”（turbulent）子数组的原因。

     我们发现，波形数组有一个很明显的递推关系：我们在已有的波形子数组上，再加一段上升或者下降段，就可以得到更长的波形子数组。
     这样一个递推关系提示我们可以用动态规划的方法来解这道题。

     我们可以这样定义子问题：定义 f(k)，f(k) 为数组 A[0..k) 中，以 A[k-1] 结尾的最长波形子数组。
     注意这里的附加条件以 A[k-1] 结尾，这是因为只有最右侧的波形子数组才可以和新加入的上升/下降段连接起来。
     这是子数组类动态规划题目中常见的定义子问题方法，例如 53. 最大子数组和 中的子问题也是有这种方法定义的。

     需要注意的是，波形数组的连接是有条件的。如果波形数组的最后一段是“上升”，就需要连上一段“下降”才是合法的波形数组；
     如果波形数组的最后一段是“下降”，就需要连上一段“上升”才是合法的波形数组。我们在写子问题递推关系的时候需要注意这一点。
     * @param A
     * @return
     */
    public int maxTurbulenceSize(int[] A) {
        if (A.length == 1) {
            return 1;
        }

        int result = 0;
        //标记，1代表上升，-1代表下降，0代表水平
        int tag = 0;
        int[] arr = new int[A.length];
        arr[0] = 1;
        for (int i = 1; i < A.length; i++) {
            //上升的情况
            if (A[i] > A[i - 1]) {

                //之前的情况,水平
                if (tag == 0) {
                    arr[i] = 2;
                }
                //之前的情况,上升
                if (tag == 1) {
                    arr[i] = 2;
                }
                //之前的情况,下降
                if (tag == -1) {
                    arr[i] = arr[i - 1] + 1;
                }
                tag = 1;
            }
            //下降的情况
            if (A[i] < A[i - 1]) {
                //之前的情况,水平
                if (tag == 0) {
                    arr[i] = 2;
                }
                //之前的情况,上升
                if (tag == 1) {
                    arr[i] = arr[i - 1] + 1;
                }
                //之前的情况,下降
                if (tag == -1) {
                    arr[i] = 2;
                }
                tag = -1;
            }
            //水平的情况
            if (A[i] == A[i - 1]) {
                arr[i] = 1;
                tag = 0;
            }


        }
        for (int n : arr) {
            if (n > result) result = n;
        }
        return result;
    }


}
